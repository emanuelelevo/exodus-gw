{"openapi": "3.0.2", "info": {"title": "exodus-gw", "description": "The exodus-gw service provides APIs for uploading and publishing content on the exodus CDN.\n\nAvailable APIs are grouped into the following categories:\n\n- [service](#tag/service): inspect the state of the exodus-gw service.\n- [upload](#tag/upload): upload blobs to the CDN without exposing them to end-users.\n  S3 compatible.\n- [publish](#tag/publish): atomically publish a set of blobs on the CDN under specified paths,\n  making them accessible to end-users.\n\n## Warning\n\nexodus-gw is in early stages of development. All APIs are subject\nto backwards-incompatible changes without warning.\n\n## Overview of API usage\n\nA typical content publishing workflow using exodus-gw will consist of:\n\n- Use the upload APIs to ensure desired blobs are uploaded.\n   - As this API is partially S3-compatible, this can typically be done using\n     an existing S3 client library.\n- Use the publish API to create a publish object and create a (URI => blob)\n  mapping for the blobs you want to publish.\n- When you are ready to expose content to end-users, commit the publish object.\n  This will atomically unveil new content at all of the requested URIs.\n\n\n## Authentication\n\nThe exodus-gw API does not include any direct support for authentication and is\ninstead expected to be deployed behind a reverse-proxy implementing any desired\nauthentication mechanism.\n\nIf you are deploying an instance of exodus-gw, see\n[the deployment guide](https://release-engineering.github.io/exodus-gw/deployment.html)\nfor information on how to integrate an authentication mechanism.\n\nIf you are a client looking to make use of exodus-gw, consult your organization's\ninternal documentation for advice on how to authenticate with exodus-gw.\n", "version": "0.1.0"}, "paths": {"/healthcheck": {"get": {"tags": ["service"], "summary": "Healthcheck", "description": "Returns a successful response if the service is running.", "operationId": "healthcheck_healthcheck_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}, "/healthcheck-worker": {"get": {"tags": ["service"], "summary": "Healthcheck Worker", "description": "Returns a successful response if background workers are running.", "operationId": "healthcheck_worker_healthcheck_worker_get", "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}}}}, "/whoami": {"get": {"tags": ["service"], "summary": "Whoami", "description": "Return basic information on the caller's authentication & authorization context.\n\nThis endpoint may be used to determine whether the caller is authenticated to\nthe exodus-gw service, and if so, which set of role(s) are held by the caller.\n\nIt is a read-only endpoint intended for diagnosing authentication issues.", "operationId": "whoami_whoami_get", "responses": {"200": {"description": "returns caller's auth context", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CallContext"}, "example": {"client": {"roles": ["someRole", "anotherRole"], "authenticated": true, "serviceAccountId": "clientappname"}, "user": {"roles": ["viewer"], "authenticated": true, "internalUsername": "someuser"}}}}}}}}, "/upload/{env}/{key}": {"put": {"tags": ["upload"], "summary": "Upload bytes", "description": "Write to an object, either as a standalone operation or within a multi-part upload.\n\nTo upload an entire object:\n- include all object bytes in request body\n- see also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html\n\nTo upload part of an object:\n- provide multipart upload ID in ``uploadId``\n- provide part number from 1 to 10,000 in ``partNumber``\n- include part of an object in request body (must be at least 5MB in size, except last part)\n- retain the `ETag` from the response, as it will be required to complete the upload\n- see also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html", "operationId": "upload_upload__env___key__put", "parameters": [{"description": "Target CDN environment", "required": true, "schema": {"title": "Env", "type": "string", "description": "Target CDN environment"}, "name": "env", "in": "path"}, {"description": "S3 object key", "required": true, "schema": {"title": "Key", "type": "string", "description": "S3 object key"}, "name": "key", "in": "path"}, {"description": "ID of an existing multi-part upload.", "required": false, "schema": {"title": "Uploadid", "type": "string", "description": "ID of an existing multi-part upload."}, "name": "uploadId", "in": "query"}, {"description": "Part number, where multi-part upload is used.", "required": false, "schema": {"title": "Partnumber", "type": "integer", "description": "Part number, where multi-part upload is used."}, "name": "partNumber", "in": "query"}], "responses": {"200": {"description": "Successful Response"}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["upload"], "summary": "Create/complete multipart upload", "description": "Create or complete a multi-part upload.\n\nTo create a multi-part upload:\n- include ``uploads`` in query string, with no value (e.g. ``POST /upload/{env}/{key}?uploads``)\n- see also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html\n\nTo complete a multi-part upload:\n- include ``uploadId`` in query string\n- include parts with ETags in request body\n- see also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CompleteMultipartUpload.html", "operationId": "multipart_upload_upload__env___key__post", "parameters": [{"description": "Target CDN environment", "required": true, "schema": {"title": "Env", "type": "string", "description": "Target CDN environment"}, "name": "env", "in": "path"}, {"description": "S3 object key", "required": true, "schema": {"title": "Key", "type": "string", "description": "S3 object key"}, "name": "key", "in": "path"}, {"description": "\nID of an existing multi-part upload.\n\nIf this argument is provided, it must be the ID of a multi-part upload\ncreated previously. The upload will be validated and completed.\n\nMust not be passed together with ``uploads``.", "required": false, "schema": {"title": "Uploadid", "type": "string", "description": "\nID of an existing multi-part upload.\n\nIf this argument is provided, it must be the ID of a multi-part upload\ncreated previously. The upload will be validated and completed.\n\nMust not be passed together with ``uploads``."}, "name": "uploadId", "in": "query"}, {"description": "\nIf this argument is provided, a new multi-part upload will be created\nand its ID returned. The provided value should be an empty string.\n\nMust not be passed together with ``uploadId``.", "required": false, "schema": {"title": "Uploads", "type": "string", "description": "\nIf this argument is provided, a new multi-part upload will be created\nand its ID returned. The provided value should be an empty string.\n\nMust not be passed together with ``uploadId``."}, "name": "uploads", "in": "query"}], "responses": {"200": {"description": "Successful Response"}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["upload"], "summary": "Abort multipart upload", "description": "Abort a multipart upload.\n\nIf an upload cannot be completed, explicitly aborting it is recommended in order\nto free up resources as early as possible, although this is not mandatory.\n\nSee also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_AbortMultipartUpload.html", "operationId": "abort_multipart_upload_upload__env___key__delete", "parameters": [{"description": "Target CDN environment", "required": true, "schema": {"title": "Env", "type": "string", "description": "Target CDN environment"}, "name": "env", "in": "path"}, {"description": "S3 object key", "required": true, "schema": {"title": "Key", "type": "string", "description": "S3 object key"}, "name": "key", "in": "path"}, {"description": "ID of a multipart upload", "required": true, "schema": {"title": "Uploadid", "type": "string", "description": "ID of a multipart upload"}, "name": "uploadId", "in": "query"}], "responses": {"200": {"description": "Empty response"}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "head": {"tags": ["upload", "upload"], "summary": "Request head object", "description": "Retrieve metadata from an S3 object.", "operationId": "head_upload__env___key__head", "parameters": [{"description": "Target CDN environment", "required": true, "schema": {"title": "Env", "type": "string", "description": "Target CDN environment"}, "name": "env", "in": "path"}, {"description": "S3 object key", "required": true, "schema": {"title": "Key", "type": "string", "description": "S3 object key"}, "name": "key", "in": "path"}], "responses": {"200": {"description": "Successful Response"}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/{env}/publish": {"post": {"tags": ["publish"], "summary": "Create new publish", "description": "Creates and returns a new publish object.", "operationId": "publish__env__publish_post", "parameters": [{"required": true, "schema": {"title": "Env", "type": "string"}, "name": "env", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Publish"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/{env}/publish/{publish_id}": {"put": {"tags": ["publish"], "summary": "Update Publish Items", "description": "Add publish items to an existing publish object.\n\nPublish items primarily are a mapping between a URI relative to the root of the CDN,\nand the key of a binary object which should be exposed from that URI.\n\nAdding items to a publish does not immediately make them available from the CDN;\nthe publish object must first be committed.\n\nItems cannot be added to a publish once it has been committed.", "operationId": "update_publish_items__env__publish__publish_id__put", "parameters": [{"required": true, "schema": {"title": "Env", "type": "string"}, "name": "env", "in": "path"}, {"required": true, "schema": {"title": "Publish Id", "type": "string", "format": "uuid"}, "name": "publish_id", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"$ref": "#/components/schemas/ItemBase"}}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/{env}/publish/{publish_id}/commit": {"post": {"tags": ["publish"], "summary": "Commit Publish", "description": "Commit an existing publish object.\n\nCommitting a publish has the following effects:\n\n- All URIs contained within the publish become accessible from the CDN,\n  pointing at their corresponding objects.\n  - This occurs with all-or-nothing semantics; see [Atomicity](#section/Atomicity).\n- The publish object becomes frozen - no further items can be added.\n\nCommit occurs asynchronously.  This API returns a Task object which may be used\nto monitor the progress of the commit.\n\nNote that exodus-gw does not resolve conflicts or ensure that any given path is\nonly modified by a single publish. If multiple publish objects covering the same\npath are being committed concurrently, URIs on the CDN may end up pointing to\nobjects from any of those publishes.", "operationId": "commit_publish__env__publish__publish_id__commit_post", "parameters": [{"required": true, "schema": {"title": "Env", "type": "string"}, "name": "env", "in": "path"}, {"required": true, "schema": {"title": "Publish Id", "type": "string", "format": "uuid"}, "name": "publish_id", "in": "path"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}}, "components": {"schemas": {"CallContext": {"title": "CallContext", "type": "object", "properties": {"client": {"title": "Client", "allOf": [{"$ref": "#/components/schemas/ClientContext"}], "default": {"roles": [], "authenticated": false}}, "user": {"title": "User", "allOf": [{"$ref": "#/components/schemas/UserContext"}], "default": {"roles": [], "authenticated": false}}}, "description": "Represents an authenticated (or not) context for an incoming request.\n\nUse the fields on this model to decide whether the current request belongs\nto an authenticated user, and if so, to determine which role(s) are held\nby the user."}, "ClientContext": {"title": "ClientContext", "type": "object", "properties": {"roles": {"title": "Roles", "type": "array", "items": {"type": "string"}, "default": []}, "authenticated": {"title": "Authenticated", "type": "boolean", "default": false}, "serviceAccountId": {"title": "Serviceaccountid", "type": "string"}}, "description": "Call context data relating to service accounts / machine users."}, "HTTPValidationError": {"title": "HTTPValidationError", "type": "object", "properties": {"detail": {"title": "Detail", "type": "array", "items": {"$ref": "#/components/schemas/ValidationError"}}}}, "Item": {"title": "Item", "required": ["web_uri", "object_key", "from_date", "publish_id"], "type": "object", "properties": {"web_uri": {"title": "Web Uri", "type": "string"}, "object_key": {"title": "Object Key", "type": "string"}, "from_date": {"title": "From Date", "type": "string"}, "publish_id": {"title": "Publish Id", "type": "string", "format": "uuid"}}}, "ItemBase": {"title": "ItemBase", "required": ["web_uri", "object_key", "from_date"], "type": "object", "properties": {"web_uri": {"title": "Web Uri", "type": "string"}, "object_key": {"title": "Object Key", "type": "string"}, "from_date": {"title": "From Date", "type": "string"}}}, "Publish": {"title": "Publish", "required": ["id"], "type": "object", "properties": {"id": {"title": "Id", "type": "string", "format": "uuid"}, "items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Item"}, "default": []}}}, "UserContext": {"title": "UserContext", "type": "object", "properties": {"roles": {"title": "Roles", "type": "array", "items": {"type": "string"}, "default": []}, "authenticated": {"title": "Authenticated", "type": "boolean", "default": false}, "internalUsername": {"title": "Internalusername", "type": "string"}}, "description": "Call context data relating to human users."}, "ValidationError": {"title": "ValidationError", "required": ["loc", "msg", "type"], "type": "object", "properties": {"loc": {"title": "Location", "type": "array", "items": {"type": "string"}}, "msg": {"title": "Message", "type": "string"}, "type": {"title": "Error Type", "type": "string"}}}}}, "tags": [{"name": "service", "description": "APIs for inspecting the state of the exodus-gw service."}, {"name": "upload", "description": "An API for uploading binary data.\n\nThis API provides endpoints for uploading files into the data store\nused by the Exodus CDN. Uploading files does not immediately expose\nthem to clients of the CDN, but is a prerequisite of publishing files,\nwhich is achieved via the [publish](#tag/publish) APIs.\n\nThe upload API is a partially compatible subset of the S3 API.\nIt supports at least enough functionality such that the boto S3\nclient and resource may be used.\n\nDifferences from the AWS S3 API include:\n\n- Most optional arguments are not supported.\n\n- All `x-amz-*` headers are omitted from responses.\n\n- The usual AWS authentication mechanism is unused; request signatures are ignored.\n  Authentication is expected to be performed by other means.\n\n- Object keys should always be SHA256 checksums of the objects being stored,\n  in lowercase hex digest form. This allows the object store to be used\n  as content-addressable storage.\n\n- When uploading content, the Content-MD5 and Content-Length headers are mandatory;\n  chunked encoding is not supported.\n\n- The API may enforce stricter limits or policies on uploads than those imposed\n  by the AWS API.\n\n## Using boto3 with the upload API\n\nAs the upload API is partially compatible with S3, it is possible to use\nexisting S3 clients such as the AWS SDK to perform uploads. This is the\nrecommended method of using the API.\n\nUse `endpoint_url` when creating a boto resource or client to point at exodus-gw.\nRegion and credentials will be ignored.\n\nNote that, as the upload API provides only a subset of the S3 API, many boto methods\nwill not work. Uploading objects and querying the existence of an object are\nsupported.\n\n```python\nimport boto3\nfrom botocore.config import Config\n\n# Prepare S3 resource pointing at exodus-gw\ns3 = boto3.resource('s3',\n                    endpoint_url='https://exodus-gw.example.com/upload',\n                    # If SSL needs to be configured:\n                    verify='/path/to/bundle.pem',\n                    config=Config(client_cert=('client.crt', 'client.key')))\n\n# Bucket name must match one of the section names in exodus-gw.ini without 'env.' prefix\nbucket = s3.Bucket('dev')\n\n# Basic APIs such as upload_file now work as usual\nbucket.upload_file('/tmp/hello.txt',\n                   'aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f')\n```\n"}, {"name": "publish", "description": "APIs for publishing blobs.\n\nIn the context of exodus-gw, \"publishing\" a blob means exposing it\nvia one or more user-accessible paths on the CDN. These blobs should first\nbe uploaded using the [upload](#tag/upload) APIs.\n\n\n## Atomicity\n\nexodus-gw aims to deliver atomic semantics for publishes; i.e., for a set\nof published content, committing the publish will make either *all* of it\navailable (if commit succeeds) or *none* of it available (if commit fails),\nwith no partial updates becoming visible from the point of view of a CDN\nclient.\n\nIn practice, limitations in the storage backend mean that true atomicity\nis not achieved for all but the smallest publishes, so it is more accurate\nto refer to the commit operation as \"near-atomic\".\n\nHere are a few of the strategies used by exodus-gw in order to ensure the\natomicity of commit:\n\n- exodus-gw performs writes to the underlying database (DynamoDB) in batches,\n  which themselves are committed atomically.\n\n  - (True atomicity could be achieved if the entire publish fits within\n     a single batch, but as batches have a maximum size of 25 items, this\n     is rarely the case.)\n\n- All operations are aggressively retried in case of error.\n\n- exodus-gw keeps track of what has been committed and is able to roll\n  back a partially committed publish in case of unrecoverable errors.\n\n- During commit, the items to be committed are prioritized intelligently\n  with knowledge of the types of content being published. Files which serve\n  as an index or entry point to a set of content are committed last, to ensure\n  minimal impact in the case that a commit is interrupted.\n\n  - Example: if a publish includes yum repositories, exodus-gw will ensure that\n    repomd.xml files are always committed last - ensuring there is no possibility\n    that an interrupted commit would unveil a repomd.xml file referencing other\n    files which were not yet committed.\n\nIt should be noted that the atomicity discussed here applies only to the interaction\nbetween exodus-gw and its underlying data store. exodus-gw does not contain any CDN\ncache purging logic; the impact of CDN caching must also be considered when evaluating\nthe semantics of a publish from the CDN client's point of view.\n\n\n## Expiry of publish objects\n\nPublish objects should be treated as ephemeral; they are not persisted indefinitely.\n\n- All publish objects which have reached a terminal state (failed or committed) will be\n  deleted after some server-defined timeout, typically one week.\n- Publish objects which have been created but not committed within a server-defined timeout,\n  typically one day, will be marked as failed.\n"}]}